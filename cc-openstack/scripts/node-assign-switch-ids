#!/usr/bin/env python
"""
node-assign-switch-ids

Intended as a migration script for https://collab.tacc.utexas.edu/issues/17386, but could
be useful later. Exists mostly as documentation and perhaps example code that can be re-used.
"""
import argparse
import operator
import re
import sys

from keystoneauth1 import adapter, loading, session
from keystoneauth1.identity import v3
from ironicclient import client

import logging
logging.basicConfig(level=logging.INFO)
LOG = logging.getLogger(__name__)

IRONIC_CLIENT_VERSION = 1


def uc_assignment_strategy(node, port):
    # Names are like c01, nc24.
    # Strip prefix and cast as integer.
    if node.name.startswith('nc'):
        link = port.local_link_connection
        switch_info = link["switch_info"]
        if switch_info == "chameleon-corsa1":
            start_id = 100
        elif switch_info == "chameleon-corsa2":
            start_id = 132
        else:
            raise ValueError((
                "Cannot figure out new port ID for node {}: unknown switch {}"
                .format(node.uuid, switch_info)
            ))
        return start_id + int(re.sub(r'^P ', '', link["port_id"]))
    elif node.name.startswith('c'):
        return 200 + int(re.sub(r'^[a-z]+', '', node.name))
    else:
        raise ValueError("Cannot figure out new port ID for node {}".format(node.uuid))


def tacc_assignment_strategy(node, port):
    link = port.local_link_connection
    switch_info = link["switch_info"]

    if switch_info == "roc-ax35-sw1":
        start_id = 100
        return start_id + int(re.sub(r'^P ', '', link["port_id"]))
    else
        raise ValueError((
            "Cannot figure out new port ID for node {}: unknown switch {}"
            .format(node.uuid, switch_info)
        ))


REGION_STRATEGIES = {
    "CHI@TACC": tacc_assignment_strategy,
    "CHI@UC": uc_assignment_strategy
}


def main(argv):
    parser = argparse.ArgumentParser(
        description='Set switch IDs for Ironic node ports')
    loading.cli.register_argparse_arguments(parser, argv, default='password')
    loading.session.register_argparse_arguments(parser)
    loading.adapter.register_argparse_arguments(parser)

    args = parser.parse_args()

    auth = loading.cli.load_from_argparse_arguments(args)
    session = loading.session.load_from_argparse_arguments(args, auth=auth)
    # Wrap session in adapter that sets interface/region
    session = adapter.Adapter(
        session=session, interface=args.os_interface, region_name=args.os_region_name)
    # Also have to pass region in here because Ironic client is a pain
    ironic = client.get_client(
        IRONIC_CLIENT_VERSION, 
        session=session,
        region_name=args.os_region_name,
        # Ironic client defaults to 1.9 currently, "latest" will be latest the API supports
        os_ironic_api_version='latest'
    )

    ports_for_update = []

    for node in ironic.node.list(sort_key='name'):
        ports = ironic.port.list(detail=True, node=node.uuid)
        
        if not ports:
            LOG.error("No ports found for node {}".format(node.uuid))
            continue
        
        port = ports[0]
        switch_info = port.local_link_connection["switch_info"]
        port_id = port.local_link_connection["port_id"]

        assignment_strategy = REGION_STRATEGIES.get(args.os_region_name)

        if not assignment_strategy:
            LOG.error("No port assignment strategy found!")
            continue

        try:
            switch_id = assignment_strategy(node, port)
        except:
            LOG.exception("Failed to assign switch_id for node")
            continue

        if int(port.local_link_connection["switch_id"]) != switch_id:
            ports_for_update.append(dict(
                node=node, uuid=port.uuid,
                switch_id=switch_id, switch_info=switch_info, port_id=port_id
            ))

        # Ensure other secondary ports have switch_id unset
        for p in ports[1:]:
            link = p.local_link_connection
            if int(link["switch_id"]) != 0:
                ports_for_update.append(dict(
                    node=node, uuid=p.uuid,
                    switch_id=0, switch_info=link["switch_info"], port_id=link["port_id"]
                ))

    for p in sorted(ports_for_update, key=lambda p: p["node"].name):
        node = p["node"]
        node_uuid = node.uuid
        node_name = node.name
        port_uuid = p["uuid"]
        padded_switch_id = str(p["switch_id"]).zfill(16)

        patch = [
            dict(
                path="/local_link_connection/switch_id", 
                value=padded_switch_id, 
                op="replace"
            )
        ]

        try:
            already_in_maintenance = node.maintenance
            
            if not already_in_maintenance:
                ironic.node.set_maintenance(node_uuid, True, 
                    maint_reason="node-assign-switch-ids: updating local_link_connection")

            ironic.port.update(port_uuid, patch)

            if already_in_maintenance:
                ironic.node.set_maintenance(node_uuid, False)

            LOG.info("{} port {} [{}:{}] updated to switch_id={}".format(
                node_name, port_uuid, p["switch_info"], p["port_id"], padded_switch_id))
        except:
            LOG.exception("failed to update port {}".format(p["uuid"]))




if __name__ == '__main__':
    sys.exit(main(sys.argv))
